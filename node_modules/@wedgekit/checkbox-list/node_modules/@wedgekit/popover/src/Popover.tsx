import React, { useEffect, useRef, useState, ReactNode } from 'react';

import { useContainingBlock } from '@wedgekit/hooks';

import { FocusOn } from 'react-focus-on';
import mergeRefs from 'react-merge-refs';

import { findPosition, getClippedViewportEdges } from './utils';

import { Wrapper } from './styled';
import { DEFAULT_OFFSET } from './utils/findPosition';
import { useOutsideScroll } from './hooks';

type Side = 'top' | 'bottom' | 'left' | 'right';
type Align = 'start' | 'center' | 'end';

export type Bearings = {
  side?: Side;
  align?: Align;
  offset?: number;
  fallback?: [Side, Align];
};

export type Position = {
  top?: number;
  left?: number;
};

export interface Props extends React.ComponentProps<typeof FocusOn> {
  // TODO [JUN-1317] Remove this as overwrite
  as?: keyof JSX.IntrinsicElements | React.ComponentType<any>;
  bearings?: Bearings;
  children: ReactNode;
  className?: string;
  node: HTMLElement;
  onExit: (e: Event | React.SyntheticEvent<MouseEvent | KeyboardEvent>) => void;
}

const Popover = React.forwardRef((props: Props, forwardedRef) => {
  const { bearings, children, className, node, onExit, ...otherProps } = props;
  const internalRef = useRef<HTMLElement>(null);
  const popoverRef = mergeRefs([internalRef, forwardedRef]);

  const [position, setPosition] = useState<Position>({});
  const { distance } = useContainingBlock(node, 'fixed');

  useEffect(() => {
    if (internalRef.current) {
      setPosition(findPosition(distance, internalRef.current.getBoundingClientRect(), bearings));
    }
  }, [node, JSON.stringify(bearings)]);

  useEffect(() => {
    if (internalRef.current && Object.keys(position).length) {
      const clippedEdges = getClippedViewportEdges(internalRef.current.getBoundingClientRect());

      if (Object.keys(clippedEdges).length) {
        if (bearings?.fallback) {
          setPosition(
            findPosition(distance, internalRef.current.getBoundingClientRect(), {
              side: bearings.fallback[0],
              align: bearings.fallback[1],
              offset: bearings.offset,
            }),
          );
        } else {
          const offset = bearings?.offset || DEFAULT_OFFSET;

          const getValue = (old: number | undefined, [side, opposite]: [Side, Side]) => {
            if (typeof old === 'number') {
              if (typeof clippedEdges[side] === 'number') {
                return old - (clippedEdges[side] as number);
              }
              if (typeof clippedEdges[opposite] === 'number') {
                return old + offset + (clippedEdges[opposite] as number);
              }
            }

            return old;
          };

          setPosition((oldPosition) => ({
            top: getValue(oldPosition.top, ['top', 'bottom']),
            left: getValue(oldPosition.left, ['left', 'right']),
          }));
        }
      }
    }
  }, [internalRef.current]);

  useOutsideScroll(internalRef, onExit);

  return (
    <Wrapper
      className={className}
      ref={popoverRef}
      onClickOutside={onExit}
      onEscapeKey={onExit}
      {...position}
      {...otherProps}
    >
      {children}
    </Wrapper>
  );
});

export default Popover;
