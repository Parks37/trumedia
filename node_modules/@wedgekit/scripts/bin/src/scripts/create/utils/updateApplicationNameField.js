import fs from 'fs';
import fsPromise from 'fs/promises';
import path from 'path';
import chalk from 'chalk';
import messages from '@utils/messages';
const onVariableUpdateError = (fileName, updatedFile) => {
    process.stderr.write(messages.error('application creation failed, failed to update variables in file', chalk.underline(fileName), 'update variables manually to use application'));
    // remove the file used to convert the variables
    fs.unlinkSync(updatedFile);
};
const placeVariablesInFile = (fileName, variables) => {
    const updatedFile = `${fileName}.updated`;
    return new Promise((resolve) => {
        const inputStream = fs.createReadStream(fileName, { encoding: 'utf8', autoClose: true });
        const outputStream = fs.createWriteStream(updatedFile, { encoding: 'utf8', autoClose: true });
        inputStream.on('data', (data) => {
            let result = data.toString();
            Object.keys(variables).forEach((key) => {
                result = result.replace(new RegExp(`{${key}}`, 'g'), variables[key]);
            });
            outputStream.write(result);
        });
        inputStream.on('end', () => {
            outputStream.end();
        });
        outputStream.on('finish', () => {
            void (async () => {
                await fsPromise.rename(updatedFile, fileName);
                resolve();
            })();
        });
        inputStream.on('error', () => onVariableUpdateError(fileName, updatedFile));
        outputStream.on('error', () => onVariableUpdateError(fileName, updatedFile));
    });
};
// update the force template files to use the application name provided
export default (options, outputDirectory) => {
    const applicationNameVariables = { applicationName: options.name };
    void placeVariablesInFile(path.resolve(outputDirectory, 'index.html'), applicationNameVariables);
    void placeVariablesInFile(path.resolve(outputDirectory, 'src', 'index.tsx'), applicationNameVariables);
};
