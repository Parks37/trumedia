#!/usr/bin/env node

// src/index.ts
import path9 from "path";
import sade from "sade";
import {readPackageUpSync as readPackageUpSync3} from "read-pkg-up";
import {fileURLToPath as fileURLToPath7} from "url";

// src/scripts/build/build.ts
import chalk2 from "chalk";
import {spawn as spawn2} from "child_process";
import fs3 from "fs/promises";
import path4 from "path";
import {readPackageUpSync as readPackageUpSync2} from "read-pkg-up";
import {fileURLToPath as fileURLToPath4} from "url";

// src/utils/filterArgs.ts
var checkFlag = (args, filters, index) => {
  if (args[index][0] === "-") {
    return !filters.includes(args[index].replace(/^-*/g, ""));
  }
  return checkFlag(args, filters, index - 1);
};
var filterArgs_default = (args, filters) => args.filter((arg, index) => checkFlag(args, filters, index));

// src/utils/messages.ts
import chalk from "chalk";
import colors from "@wedgekit/palette";
var messages = {
  error: (...args) => chalk.hex(colors.R500)("\u274C", ...args, "\n"),
  header: (...args) => chalk.hex(colors.B300)(...args, "\n"),
  success: (...args) => chalk.hex(colors.G600)(...args, "\n"),
  text: (...args) => chalk.hex(colors.B400)(...args, "\n"),
  warning: (...args) => chalk.hex(colors.Y300)(...args, "\n")
};
var messages_default = messages;

// src/utils/createViteConfig.ts
import fs from "fs/promises";
import path from "path";
import {fileURLToPath} from "url";

// src/utils/getViteConfig.ts
import dotenv from "dotenv";
import {readPackageUpSync} from "read-pkg-up";
var {parsed} = dotenv.config();
var pkg = readPackageUpSync()?.packageJson;
var deps = ["ag-grid-community", "focus-trap-react", "react", "react-dates", "react-dom"];
var checkParsed = () => {
  if (parsed) {
    if (Object.keys(parsed).some((key) => !key.startsWith("WEDGEKIT"))) {
      console.warn(`Hi there, it looks like you are trying to include some environment variables, but they weren't prefixed with 'WEDGEKIT'.
          Only environment variables prefixed with 'WEDGEKIT' will be made available to the build.`);
    }
  }
};
var getDefined = () => {
  Object.keys(process.env).reduce((record, key) => {
    if (key.substring(0, 8) === "WEDGEKIT") {
      return {
        ...record,
        [`process.env.${key}`]: JSON.stringify(process.env[key])
      };
    }
    return record;
  }, {});
};
var getProxy = (opts) => {
  const proxies = {};
  if (opts["graphql-proxy"]) {
    console.info(`Configuring graphql proxy with ${opts["graphql-proxy"]}`);
    proxies["/graphql"] = {target: opts["graphql-proxy"], changeOrigin: true};
  }
  return proxies;
};
var getViteConfig = (opts) => {
  checkParsed();
  return {
    build: {
      commonjsOptions: {
        transformMixedEsModules: true
      }
    },
    define: getDefined(),
    server: {
      fs: {
        allow: ["../.."]
      },
      proxy: getProxy(opts)
    },
    optimizeDeps: {
      include: deps.filter((dep) => Object.keys(pkg?.dependencies || {}).includes(dep))
    },
    resolve: {
      dedupe: ["react", "react-dom"],
      extensions: [".ts", ".tsx", "d.ts", ".mjs", ".js", ".jsx", ".json"]
    }
  };
};
var getViteConfig_default = getViteConfig;

// src/utils/createViteConfig.ts
var createViteConfig = async (opts) => {
  const viteConfig = getViteConfig_default(opts);
  await fs.writeFile(path.resolve(path.dirname(fileURLToPath(import.meta.url)), "configs/vite.config.js"), String.raw`import appAssets from './rollup-app-assets-plugin.js';

const config = JSON.parse('${JSON.stringify(viteConfig)}');

config.plugins = [appAssets()];

export default config;
`);
};
var createViteConfig_default = createViteConfig;

// src/scripts/build/bundle.ts
import esbuild from "esbuild";
import {globby} from "globby";
var bundle = async (pkg2, opts) => {
  process.stdout.write(messages_default.text("bundling package"));
  const watchOpts = {
    onRebuild: (error) => {
      if (error) {
        process.stderr.write(messages_default.error(error));
      } else {
        process.stdout.write(messages_default.text("package built"));
      }
    }
  };
  const external = [
    ...Object.keys(pkg2.dependencies || {}),
    ...Object.keys(pkg2.peerDependencies || {})
  ];
  if (opts.script) {
    esbuild.build({
      entryPoints: ["src/index.ts"],
      external,
      bundle: true,
      platform: "node",
      target: `node14.0`,
      format: "esm",
      outdir: "bin",
      minify: !opts.dev,
      sourcemap: opts.dev ? "inline" : false,
      watch: opts.watch && watchOpts
    }).then(() => process.stdout.write(messages_default.success("node bundle created"))).catch(() => process.exit(1));
  } else {
    esbuild.build({
      entryPoints: ["src/index.ts"],
      external,
      bundle: true,
      target: "es2019",
      format: "esm",
      outdir: "dist",
      minify: !opts.dev,
      sourcemap: opts.dev ? "inline" : false,
      outExtension: {
        ".js": ".esm.js"
      },
      watch: opts.watch && watchOpts
    }).then(() => process.stdout.write(messages_default.success("esm bundle created"))).catch(() => process.exit(1));
    esbuild.build({
      entryPoints: ["src/index.ts"],
      external,
      bundle: true,
      format: "cjs",
      target: "node12",
      outdir: "dist",
      minify: !opts.dev,
      sourcemap: opts.dev ? "inline" : false,
      outExtension: {
        ".js": ".cjs"
      },
      watch: opts.watch && watchOpts
    }).then(() => process.stdout.write(messages_default.success("cjs bundle created"))).catch(() => process.exit(1));
    if (opts.unbundled) {
      esbuild.build({
        entryPoints: await globby("src/**/*.ts"),
        bundle: false,
        target: "es2019",
        format: "esm",
        outdir: "dist",
        minify: !opts.dev,
        sourcemap: opts.dev ? "inline" : false,
        watch: opts.watch && watchOpts
      }).then(() => process.stdout.write(messages_default.success("unbundled files added"))).catch(() => process.exit(1));
    }
  }
};
var bundle_default = bundle;

// src/scripts/build/type.ts
import {spawn} from "child_process";
import fs2 from "fs/promises";
import path3 from "path";
import {fileURLToPath as fileURLToPath3} from "url";

// src/scripts/build/tsconfig.ts
import {existsSync} from "fs";
import path2 from "path";
import slash from "slash";
import {fileURLToPath as fileURLToPath2} from "url";
var getConfigPath = () => {
  const currentPath = slash(path2.resolve(path2.dirname(fileURLToPath2(import.meta.url)), "../temp"));
  const configPath = slash(path2.relative(process.cwd(), "tsconfig.json"));
  if (existsSync(configPath)) {
    const relativePath = slash(path2.relative(currentPath, configPath));
    const index = relativePath.lastIndexOf(".");
    return relativePath.substring(0, index);
  }
  return void 0;
};
var tsconfig_default = {
  extends: getConfigPath(),
  include: [slash(path2.resolve(process.cwd(), "src/**/*"))],
  exclude: [
    slash(path2.resolve(process.cwd(), "**/*.test.ts")),
    slash(path2.resolve(process.cwd(), "dist")),
    slash(path2.resolve(process.cwd(), "../../", "node_modules/**/*")),
    slash(path2.resolve(process.cwd(), "node_modules/**/*"))
  ],
  compilerOptions: {
    allowSyntheticDefaultImports: true,
    declaration: true,
    emitDeclarationOnly: true,
    esModuleInterop: true,
    jsx: "react",
    moduleResolution: "node",
    outDir: slash(path2.resolve(process.cwd(), "dist")),
    skipLibCheck: true,
    strict: true,
    target: "ES2019"
  }
};

// src/scripts/build/type.ts
var onError = (message) => {
  process.stderr.write(messages_default.error("TypeScript definitions failed"));
  process.stderr.write(messages_default.warning(message));
  process.exit(1);
};
var define = ({watch}) => {
  const args = [
    "--project",
    `${path3.resolve(path3.dirname(fileURLToPath3(import.meta.url)), "../temp/tsconfig.json")}`
  ];
  const tsc = spawn("tsc", watch ? [...args, "-w"] : args, {shell: true});
  tsc.stdout.on("data", (data) => process.stdout.write(messages_default.text(data)));
  tsc.stderr.on("data", onError);
  tsc.on("error", (error) => onError(error.message));
  tsc.on("exit", (code) => {
    if (code !== 1) {
      process.stdout.write(messages_default.success("TypeScript definitions complete"));
    }
    process.exit(code || void 0);
  });
};
var mkdir = async () => {
  await fs2.mkdir(path3.resolve(path3.dirname(fileURLToPath3(import.meta.url)), "../temp"), {
    recursive: true
  });
  await fs2.writeFile(path3.resolve(path3.dirname(fileURLToPath3(import.meta.url)), "../temp/tsconfig.json"), JSON.stringify(tsconfig_default));
};
var type = (opts) => {
  process.stdout.write(messages_default.text("creating TypeScript definitions"));
  mkdir().then(() => {
    define(opts);
  }).catch((e) => onError(e.message));
};
var type_default = type;

// src/scripts/build/build.ts
var flags = [
  "clean",
  "c",
  "dev",
  "d",
  "package",
  "p",
  "script",
  "s",
  "types-only",
  "t",
  "watch",
  "w"
];
var directory = process.cwd();
var build = async (opts) => {
  const pkg2 = readPackageUpSync2()?.packageJson;
  process.stdout.write(messages_default.header("building", chalk2.bold(`${pkg2.name}`)));
  if (opts.package || opts.script) {
    const clean = async () => {
      if (opts.clean) {
        await fs3.rm(path4.resolve(directory, "dist"), {recursive: true, force: true});
      }
    };
    void clean().then(() => {
      if (opts.script || !opts["types-only"]) {
        void bundle_default(pkg2, opts);
      }
      if (!opts.script)
        type_default(opts);
    });
  } else {
    await createViteConfig_default(opts);
    const viteArgs = filterArgs_default(process.argv.slice(3), flags);
    const config = [
      "-c",
      path4.resolve(path4.dirname(fileURLToPath4(import.meta.url)), "configs/vite.config.js")
    ];
    const minifySettings = opts.dev ? [] : ["--minify"];
    const viteBuild = spawn2("vite", ["build", ...config, ...minifySettings, ...viteArgs], {
      shell: true
    });
    viteBuild.stdout.on("data", (data) => process.stdout.write(messages_default.text(data)));
    viteBuild.stderr.on("data", (data) => process.stderr.write(messages_default.error(data)));
    viteBuild.on("error", (error) => process.stderr.write(messages_default.error(error.message)));
    viteBuild.on("exit", (code) => {
      if (code !== 1) {
        process.stdout.write(messages_default.text("server stopped"));
      }
      process.exit(code || void 0);
    });
  }
};
var build_default = build;

// src/scripts/create/create.ts
import chalk5 from "chalk";

// src/scripts/create/mkdir.ts
import chalk3 from "chalk";
import fs4 from "fs/promises";
import path5 from "path";

// src/utils/prettyCatch.ts
var prettyCatch = async (cb) => {
  const response = [void 0, void 0];
  await cb().then((data) => {
    response[1] = data;
  }).catch((e) => {
    response[0] = e;
  });
  return response;
};
var prettyCatch_default = prettyCatch;

// src/scripts/create/mkdir.ts
var mkdir2 = async (name) => {
  const testDir = async () => {
    const files2 = [];
    const directory2 = await fs4.opendir(path5.resolve(process.cwd(), name));
    for await (const dirent of directory2) {
      files2.push(dirent.name);
    }
    return files2;
  };
  const [error, files] = await prettyCatch_default(testDir);
  if (error) {
    if (error.code === "ENOENT") {
      process.stdout.write(messages_default.text(`creating ${name} directory`));
      await fs4.mkdir(path5.resolve(process.cwd(), name));
    } else {
      process.stderr.end(messages_default.error(`package creation failed
        ${error.message}`));
    }
  } else if (files?.length) {
    process.stderr.end(messages_default.error(`package creation failed - ${chalk3.underline(name)} already exists and cannot be overwritten`));
    process.exit(1);
  }
};
var mkdir_default = mkdir2;

// src/scripts/create/scaffold.ts
import fs6 from "fs/promises";
import ncp from "ncp";
import path7 from "path";
import {fileURLToPath as fileURLToPath5} from "url";

// src/scripts/create/utils/createPackage.ts
import version from "latest-version";
var generateDescription = (options) => {
  if (options.desc)
    return options.desc;
  if (options.script)
    return "DMSi node script";
  return "DMSi Agility Application";
};
var getScripts = (options) => ({
  start: `wedgekit start${options.script ? " -s" : ""}`,
  build: `wedgekit build${options.script ? " -s" : ""}`
});
var getDependencies = async (options) => {
  const applicationPackages = {
    react: "17.0.2",
    "react-dom": "17.0.2",
    "styled-components": "4.3.1"
  };
  if (options.script)
    return {
      "@wedgekit/color": await version("@wedgekit/color"),
      chalk: "^4.1.1"
    };
  if (options.template === "basic") {
    return applicationPackages;
  }
  return {
    ...applicationPackages,
    "react-router-dom": "5.3.0"
  };
};
var getDevDependencies = (options) => {
  if (options.script)
    return {};
  return {
    "@types/react": "17.0.3",
    "@types/react-dom": "17.0.3",
    vite: "2.4.1"
  };
};
var createPackage_default = async (options) => ({
  name: options.name,
  version: "0.0.0",
  description: generateDescription(options),
  license: "MIT",
  private: true,
  scripts: {
    test: "ava",
    ...getScripts(options)
  },
  dependencies: {
    ...await getDependencies(options)
  },
  devDependencies: {
    "@wedgekit/scripts": "latest",
    ava: "3.15.0",
    "ts-node": "9.1.1",
    typescript: "4.3.4",
    ...getDevDependencies(options)
  },
  type: "module"
});

// src/scripts/create/utils/updateApplicationNameField.ts
import fs5 from "fs";
import fsPromise from "fs/promises";
import path6 from "path";
import chalk4 from "chalk";
var onVariableUpdateError = (fileName, updatedFile) => {
  process.stderr.write(messages_default.error("application creation failed, failed to update variables in file", chalk4.underline(fileName), "update variables manually to use application"));
  fs5.unlinkSync(updatedFile);
};
var placeVariablesInFile = (fileName, variables) => {
  const updatedFile = `${fileName}.updated`;
  return new Promise((resolve) => {
    const inputStream = fs5.createReadStream(fileName, {encoding: "utf8", autoClose: true});
    const outputStream = fs5.createWriteStream(updatedFile, {encoding: "utf8", autoClose: true});
    inputStream.on("data", (data) => {
      let result = data.toString();
      Object.keys(variables).forEach((key) => {
        result = result.replace(new RegExp(`{${key}}`, "g"), variables[key]);
      });
      outputStream.write(result);
    });
    inputStream.on("end", () => {
      outputStream.end();
    });
    outputStream.on("finish", () => {
      void (async () => {
        await fsPromise.rename(updatedFile, fileName);
        resolve();
      })();
    });
    inputStream.on("error", () => onVariableUpdateError(fileName, updatedFile));
    outputStream.on("error", () => onVariableUpdateError(fileName, updatedFile));
  });
};
var updateApplicationNameField_default = (options, outputDirectory) => {
  const applicationNameVariables = {applicationName: options.name};
  void placeVariablesInFile(path6.resolve(outputDirectory, "index.html"), applicationNameVariables);
  void placeVariablesInFile(path6.resolve(outputDirectory, "src", "index.tsx"), applicationNameVariables);
};

// src/scripts/create/utils/templateOptions.ts
var availableTemplateFlagOptions = ["basic", "force"];
var getTemplate = (options) => {
  if (options.script) {
    return "templates/script";
  }
  if (options.template === "basic") {
    return "templates/basic";
  }
  return "templates/force";
};

// src/scripts/create/scaffold.ts
var {ncp: copy} = ncp;
var scaffold = async (options) => {
  const outputDirectory = path7.resolve(process.cwd(), options.dir || options.name);
  copy(path7.resolve(path7.dirname(fileURLToPath5(import.meta.url)), getTemplate(options)), outputDirectory, (err) => {
    if (err) {
      process.stderr.write(messages_default.warning("Scaffolding not created", ...err.map(({message}) => message)));
      process.exit(1);
    }
    if (!options.template || options.template === "force") {
      updateApplicationNameField_default(options, outputDirectory);
    }
  });
  const pkg2 = await createPackage_default(options);
  await fs6.writeFile(path7.resolve(outputDirectory, "package.json"), JSON.stringify(pkg2, null, 2));
};
var scaffold_default = scaffold;

// src/scripts/create/create.ts
var create = async (name, opts) => {
  process.stdout.write(messages_default.header("creating", chalk5.bold(`${name}`)));
  if (opts.package) {
    process.stderr.write(messages_default.warning("\u26A0\uFE0F ", chalk5.underline("wedgekit create"), "is only configured for web apps."));
    process.exitCode = 1;
  } else if (opts.template && !availableTemplateFlagOptions.includes(opts.template)) {
    process.stderr.write(messages_default.error(chalk5.underline("wedgekit create"), `is not configured for template type ${opts.template}`));
    process.exitCode = 1;
  } else {
    await mkdir_default(opts.dir || name);
    await scaffold_default({name, ...opts});
  }
};
var create_default = create;

// src/scripts/start/start.ts
import chalk6 from "chalk";
import {spawn as spawn3} from "child_process";
import path8 from "path";
import {fileURLToPath as fileURLToPath6} from "url";
var flags2 = ["graphql-proxy"];
var handleOutput = (command, args) => {
  const server = spawn3(command, args, {shell: true, stdio: "inherit"});
  server.on("error", (error) => process.stderr.write(messages_default.error(error.message)));
  server.on("exit", (code) => {
    if (code !== 1) {
      process.stdout.write(messages_default.text("server stopped"));
    }
    process.exit(code || void 0);
  });
};
var start = async (opts) => {
  if (opts.script) {
    handleOutput("node", [
      "--loader",
      "ts-node/esm",
      "--experimental-specifier-resolution=node",
      "--no-warnings",
      "./src/index.ts"
    ]);
  } else {
    await createViteConfig_default(opts);
    process.stdout.write(messages_default.text(chalk6.bold("starting dev server")));
    const config = [
      "-c",
      path8.resolve(path8.dirname(fileURLToPath6(import.meta.url)), "configs/vite.config.js")
    ];
    const options = filterArgs_default(process.argv.slice(3), flags2);
    handleOutput("vite", [...config, "--open", "-l", "info", ...options]);
  }
};
var start_default = start;

// src/index.ts
var wedgekit = sade("wedgekit");
wedgekit.version(readPackageUpSync3({cwd: path9.dirname(fileURLToPath7(import.meta.url))})?.packageJson.version);
wedgekit.option("--package -p --library -l", "Indicates use is for package development (as opposed to a node script or web app)").option("-s, --script", "Indicates use as a node script, for example for use in GitHub actions (as opposed to a package or web app)");
wedgekit.command("create <name>").describe("creates a new A2W web app").option("-d, --dir", "Defines the location of the application; defaults to <name>").example("create test --dir apps/test").option("--desc", "Adds a description to the scaffolded package.json").example('create test -desc "My Application"').option("-template", "Defines the template pattern to use; available options are force and basic; defaults to force").example("create test --template basic").action(create_default);
wedgekit.command("build").describe("builds the src directory; expects an src/index.ts entry file.").option("-c, --clean", "Removes the dist directory before building package").option("-d, --dev", "Builds with dev options set to true; used for local development").option("-u, --unbundled", "Adds the unbundled files in addition to the ESM and CJS bundles").option("-t, --types-only", "Only builds type declaration files; used for type-only packages").option("-w, --watch", "Watches source files for changes that would invalidate the build and rebuilds").action(build_default);
wedgekit.command("start").describe("starts a dev server for local app development").option("--graphql-proxy", "Sets up a proxy middleware to the desired graphql endpoint.").example("start --graphql-proxy https://myBranch.agility.dmsi.io/graphql").action(start_default);
wedgekit.parse(process.argv);
